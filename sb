#!/bin/sh
# Statusbar generator.

# default option values
output=xrootname
action=run

# directory for runtime files
tmpdir=/tmp/sb$DISPLAY

# module: audio
aud() {
	runck 10 upd || return
	info=$(amixer get Master)
	case $info in
		*Mono:*'[on]')
			info=${info#*\[}
			perc="${info%%\]*}" ;;
		*Mono:*'[off]')
			perc=off ;;
		*)
			perc=err ;;
	esac
	aud="AUD: $perc"
}

# module: battery percentage
bat() {
	runck 20 || return
	read -r percentage </sys/class/power_supply/BAT0/capacity
	read -r status </sys/class/power_supply/BAT0/status
	if [ "$status" = Charging ]; then
		perc="charging:$percentage%"
	elif [ "$percentage" -eq 100 ]; then
		perc="full:$percentage%"
	elif [ "$percentage" -gt 14 ]; then
		perc="$percentage%"
	else
		perc="low:$percentage%"
	fi
	bat="BAT: $perc"
}

# module: display brightness
disp() {
	runck 10 upd || return
	read -r curr </sys/class/backlight/intel_backlight/brightness
	read -r max  </sys/class/backlight/intel_backlight/max_brightness
	disp="DISP: $((curr * 100 / max))%"
}

# module: keyboard layout
lang() {
	runck 10 upd || return
	lang="LANG: $(setxkbmap -query | awk '/layout/{print $2}')"
}

# module: rss updates
rss() {
	runck 60 || return
	last=$(stat -c%X ~/.sfeed/last)
	new=$(awk -v ts="$last" '$1 > ts' ~/.sfeed/feeds/* | wc -l)
	case $new in
		0) updates=none ;;
		*) updates="new:$new" ;;
	esac
	rss="RSS: $updates"
}

# module: date and time
datetime() {
	datetime=$(date +'DATE: %a %-e %b %H:%M:%S')
}

# output the statusline
showstatus() {
	case $output in
		xrootname) xsetroot -name "$statusline" ;;
		stdout) echo "$statusline"
	esac
}

# check if job should be run
runck() {
	interval=$1 # normal job interval
	updonhup=$2 # not null if job should be run at sighup
	[ "$updonhup" ] && [ "$hup" ] || [ "$((tick % interval))" = 0 ]
}

# recompute values and update statusline
recompute() {
	for func in aud disp bat lang rss datetime; do
		$func
	done
	statusline=" ${aud} | ${disp} | ${bat} | ${lang} | ${rss} | ${datetime} "
}

# cleanup and exit
finish() {
	rm -rf "$tmpdir"
	exit
}

# prepare for running the main loop
setup() {
	mkdir "$tmpdir" 2>/dev/null || {
		echo "error: statusbar for the display $DISPLAY is already running"
		return 1
	}
	trap finish EXIT TERM INT
	echo $$ >"$tmpdir/pid"
}

# main loop
sbloop() {
	setup || return
	trap hup=true HUP # sighup is used for update signalling
	while : ; do
		# update values
		recompute
		# set statusline
		showstatus || exit
		# increment counter
		tick=$(((tick + 1) % 256))
		# clear sighup flag and sleep
		hup=
		sleep 1
	done
}

# request statusline update
update() {
	pid=$(cat "$tmpdir/pid" 2>/dev/null) || {
		echo "error: no active instance for the display $DISPLAY"
		return 1
	}
	kill -HUP "$pid"
}

# parse options
while getopts ":xsu" opt; do
	case $opt in
		x) output=xrootname ;;
		s) output=stdout ;;
		u) action=update ;;
		*)
			echo "usage: ${0##*/} [-xsu]"
			exit 1
	esac
done

# check that DISPLAY is set
[ "$DISPLAY" ] || {
	echo 'error: DISPLAY variable is not set'
	exit 1
}

# run
case $action in
	run) sbloop ;;
	update) update ;;
esac
